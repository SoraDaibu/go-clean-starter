📖 **English version**: [README.md](./README.md)

[**Wire**](https://github.com/google/wire)は、Go用のコンパイル時依存性注入（DI）ツールです。コンストラクタ（初期化された型を返す関数）を分析し、それらを結合する「接着」コードを自動的に生成します。つまり、ビルダー関数で各`NewFoo(...)`を手動で呼び出す代わりに、`wire.Build(...)`文ですべてのコンストラクタを宣言すると、Wireが正確な呼び出しシーケンスを書いてくれます。

---

## Wireの用途

1. **配線ロジックの集中化と検証**

   * 各コンストラクタを一度だけ記載します。Wireはそれらのシグネチャを検査し、コンパイル時に依存関係グラフを構築します。
   * コンストラクタに必要な入力が不足している場合、または2つのコンストラクタが互換性がなくなった場合、Wireは即座に明確なエラーで失敗し、どのプロバイダーが不足または不一致かを正確に指摘します。

2. **ボイラープレートコードの生成**

   * `LoadConfig()`、`NewLogger()`、`NewDBClient()`などを呼び出す長い「BuildServer」関数を手書きする代わりに、Wireが生成ファイル（`wire_gen.go`）でそのコードを書いてくれます。
   * その生成ファイルを編集したり保守したりする必要はありません。コンストラクタと`wire.go`の宣言のみを保守します。

3. **DIを明示的だが自動化された状態に保つ**

   * すべてのコンストラクタは通常のGo関数のままです。Wireはランタイムリフレクションやマジックを追加しません。ビルド時に`wire`を実行すると、プレーンなGoコードが生成され、あなたがそのコードを自分で書いたかのようにアプリケーションがコンパイルされます。

---

## Wireを使用する利点

1. **コンパイル時安全性**

   * コンストラクタのシグネチャを変更した場合（例：新しいパラメータを追加）、Wireは即座に「未バインドプロバイダー」または「型XをYに割り当てることができません」と報告するため、プログラムを実行する前に配線を修正できます。
   * 不足または互換性のない依存関係を、ランタイムではなくビルドプロセスの一部として検出できます。

2. **大規模な依存関係グラフでのスケーラビリティ**

   * 10以上のコンストラクタがある場合、手動配線は冗長でエラーが発生しやすくなります。Wireは、各コンストラクタの入力と出力を検査して全体のグラフを構築することで、引数を忘れたり呼び出しを誤った順序にしたりすることを防ぎます。
   * サービスの追加や削除は、`wire.go`の1つのリストを更新することを意味し、Wireが使用されるすべての場所で生成コードを更新します。

3. **実装の交換が容易（テストや代替モード用）**

   * `wire.Bind`や`wire.Value`を使用して、インターフェースを満たす方法やスタブ/モックを注入する方法をWireに指示できます。
   * テストインジェクタ（例：`InitializeTestServer`）を別々に定義できます — Wireは同じコンストラクタにフェイクを渡すボイラープレートを生成し、テストセットアップが本番コンストラクタと同期を保つことを自動的に保証します。

4. **共有コア依存関係を持つ複数のエントリーポイントをサポート**

   * HTTPサーバー、CLIツール、バックグラウンドワーカー、スケジュールされたジョブがある場合、各エントリーポイントは多くの場合同じコンポーネントの大部分を共有します（Config → Logger → DB → Repository → ServiceAなど）。Wireを使用すると、すべて同じコンストラクタを参照する3つの異なるインジェクタ（`InitializeServer`、`InitializeWorker`、`InitializeCLI`）を単純に宣言できます。
   * 配線ロジックの80%を3回コピー＆ペーストすることを避けられます — Wireは共有プロバイダーリストに基づいて各インジェクタのコードを生成します。

5. **クリーンで読みやすいコード分離**

   * 「ビジネスロジック」コンストラクタは独自のファイル（例：`db.go`、`repo.go`、`service.go`）に残ります。コンストラクタの大きなリストを見る唯一の場所は`wire.go`です。
   * `main.go`は最小限のままです：`InitializeServer()`（または`InitializeWorker()`）を呼び出し、エラーをチェックし、プロセスを開始するだけです。「物事をどのように配線するか」はすべてWireの生成コードにカプセル化されています。

6. **CI/CDセーフティネット**

   * CI パイプラインに`wire`を追加できます。コンストラクタを変更した後に誰かが`wire.Build(...)`の更新を忘れた場合、`wire`が失敗してビルドが壊れます。壊れた配線を本番環境に誤って出荷することはありません。
   * Wireのエラーは明示的なので、どのコンストラクタやプロバイダーが不足しているかをすぐに知ることができます。

7. **ランタイムリフレクションやパフォーマンスオーバーヘッドなし**

   * 生成されたコードはプレーンなGoです：リフレクション、隠れたランタイムコンテナ、ルックアップテーブルはありません — すべてがコンパイル時に解決されます。起動パフォーマンスは手動で書いた配線と同じです。

---

詳細については[WireのGithub](https://github.com/google/wire)を参照してください。

---

