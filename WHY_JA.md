# `go-clean-starter`の技術選択について

📖 **English version**: [WHY.md](./WHY.md)

このドキュメントでは、`go-clean-starter`における主要な技術選択の理由を説明します。
開発者がスタック内の各主要ツールやライブラリの目的と何故各ツールが選定されたのかをを素早く理解できるようにすることを目的としています。

## 🧱 背景

`go-clean-starter`は**Go**で構築され、**クリーンアーキテクチャ**の原則に基づいて設計されたバックエンドテンプレートです。スケーラブルで、テスト可能で、保守しやすいアプリケーションの堅実な基盤を提供することを目指しており、小〜中規模のチーム、社内ツールに適しています。

## 🧠 主要な決定事項

### 🔹 言語: **Go**

Goを選択した理由：
- シンプルさと明確性
- 高いパフォーマンスと低いリソース使用量
- 素晴らしい並行処理機能
- バックエンドとDevOpsのための強力なエコシステム

---

### 🔹 Webフレームワーク: **Echo**

[Echo](https://github.com/labstack/echo)をHTTPフレームワークとして使用する理由：
- 高速で軽量
- クリーンで直感的なルーター
- 豊富で拡張可能なミドルウェアサポート
- `net/http`との統合が容易で、REST APIシナリオでうまく機能する

---

### 🔹 データベース: **PostgreSQL**

PostgreSQLを主要データベースとして選択した理由：
- 信頼性が高く、オープンソースで、広く採用されている
- JSONB、全文検索、強い一貫性などの豊富な機能をサポート
- ORMと生SQLワークフローの両方でうまく機能する

---

- [`golang-migrate`](https://github.com/golang-migrate/migrate)はスキーマのバージョン管理に使用されており、`golang-migrate`が様々なデータベースをサポートし、シンプルであることから選択されました。

---

### 🔹 SQLツール: **sqlc + golang-migrate**

* **[`sqlc`](https://github.com/kyleconroy/sqlc)** は生のSQLクエリから**型安全なGoコード**を生成します。

  * ビジネスクエリをデータベースに近い場所に保持し、透明性とデバッグを向上させます。
  * ランタイムリフレクションなし — コンパイル時に効率的で安全です。
  * Goには詳しくないSQLに精通した開発者が効果的に貢献しやすくします。
  * また、生SQLを書いてから関数化することで生SQLを利用可能にし、デバッグ性を向上させます。

* **[`golang-migrate`](https://github.com/golang-migrate/migrate)** は`.up.sql`と`.down.sql`ファイルを使用して生SQLでスキーママイグレーションを処理します。
  * バージョン管理、ロック、ロールバックをサポートします。
  * 複数のマイグレーションプロセスが同時に実行される際の競合を防ぐ組み込みメカニズムがあり、CI/CDとマルチ環境デプロイメントでうまく機能します。

---

### 🔹 OpenAPIコード生成: **[oapi-codegen](https://github.com/oapi-codegen/oapi-codegen)**

**oapi-codegen**はOpenAPI仕様からGoの構造体と型を生成するために使用されています：

* **API仕様と実装間の型安全性**
  * OpenAPIスキーマ定義に一致するGo型を自動生成し、ドキュメントとコード間の一貫性を保証します。
  * リクエスト/レスポンス構造の不一致によるランタイムエラーを防ぎます。

* **単一の信頼できる情報源**
  * OpenAPI仕様（`doc/api.yaml`）がAPIコントラクトの権威ある定義として機能します。
  * APIスキーマの変更は再生成を通じて自動的にGoコードに反映されます。

* **ボイラープレートと保守作業の削減**
  * リクエスト/レスポンス構造体を手動で書いて保守する必要がなくなります。
  * 複雑なネストした構造、バリデーションタグ、型変換を自動的に処理します。

oapi-codegenは、API実装がその仕様と同期を保つことを保証し、バグを減らし、REST APIを扱う際の開発者の生産性を向上させます。

---

### 🔹 依存性注入: **手動実装**

**手動依存性注入**を使用して、オブジェクトの初期化をクリーン、明示的、かつ保守しやすく保っています：
* シンプルで慣用的 — 追加ツールなしで標準的なGoの慣習に従います
* 明示的な依存関係グラフにより、コードが読みやすくデバッグしやすくなります
* ビルド時のコード生成や追加の依存関係が不要です
* コンストラクタは`builder`パッケージに集中化されています
* モジュラーでテスト可能なアーキテクチャを促進します（特にクリーンアーキテクチャのセットアップで有用）

手動DIは、サービス、リポジトリ、外部クライアントの数が増加しても、明確性を犠牲にすることなくプロジェクトをシンプルで保守しやすく保ちます。

### 🔹 ホットリロード: **[air](https://github.com/air-verse/air)**

**Air**は開発中のホットリロードに使用されています：
* Goソースファイルが変更されたときに高速で自動的な再ビルドを提供し、開発者の生産性を大幅に向上させます。
* 軽量で焦点が絞られている — 不要な複雑さなしにGoアプリケーション専用に設計されています。
* `.air.toml`ファイルで設定可能で、監視ディレクトリ、ビルドコマンド、除外パターンのカスタマイズが可能です。
* Dockerとコンテナ化された開発環境でシームレスに動作します。

Airは開発中の手動停止、再ビルド、アプリケーション再起動の面倒なサイクルを排除し、反復的なコーディングのフィードバックループを高速化してくれます。

---
## ✏️ 検討した代替案

### **データベース: MySQL**

以下の理由で`PostgreSQL`を優先し、`MySQL`を見送りました：

1. **高度な機能セット**

   * PostgreSQLは行レベルセキュリティ（RLS）、ネイティブインデックス付きJSONB、より豊富なインデックスオプション（GIN、GiST、部分インデックス）、組み込み全文検索をサポートしています。
   * MySQLはJSONBとこれらの高度なインデックス機能を欠いており、回避策なしに半構造化データや複雑なテキストクエリを処理することが困難です。

2. **拡張エコシステム**

   * PostgreSQLには、PostGIS（地理空間クエリ用）やpg_trgm（類似検索用）などの成熟した拡張があります。
   * MySQLのエコシステムは、同等の組み込み地理空間や高性能テキスト検索サポートを提供していません。

3. **進化する要件への柔軟性**

   * PostgreSQLのJSONBは、別のNoSQLストアを必要とせずに動的構造を保存・クエリできます。
   * MySQLのより限定的な機能セットは、将来のユースケースがより豊富なデータ型やインデックスを要求する際にボトルネックになる可能性があります。

---

### **マイグレーションツール: [Goose](https://github.com/pressly/goose)**

`Goose`も検討されましたが、`golang-migrate`を選択しました：

1. **マルチデータベースサポート**

   * `golang-migrate`はPostgreSQL、MySQL、SQLite、MongoDB、Cassandraなどに対応してします。
   * Gooseはサポートするデータベースが少なく、柔軟性を制限する可能性があります。様々な技術スタックに対応するスターターテンプレートを作りたかったので、`golang-migrate`に軍配が上がりました。

2. **ロックと並行性**

   * `golang-migrate`はアドバイザリロック（例：PostgreSQLアドバイザリロック）を使用して、CI/CDやマルチ開発者環境で一度に1つのマイグレーションのみが実行されることを保証します。
   * Gooseには組み込みアドバイザリロックがなく、競合状態を避けるために外部調整が必要です。

3. **拡張可能なCLI**

   * `golang-migrate`には`version`、`status`、`force`などのコマンドが含まれ、自動化されたワークフローのためのDockerベースのパイプラインとスムーズに統合されます。
   * GooseのCLI（`up`、`down`、`fix`、`status`、`version`）はよりシンプルですが、複雑なCI/CDシナリオでは柔軟性に欠けます。

---

### **ORM: [GORM](https://gorm.io/)**

`GORM`は以下の理由で`sqlc`を優先して見送られました：

1. **コンパイル時安全性**
   * `sqlc`はSQLクエリからGoコードを生成し、スキーマ-クエリの不一致がコンパイル時に検出されることを保証します。
   * GORMはランタイムリフレクションに依存し、実行まで隠れたエラーが発生する可能性があります。

2. **明示的SQLとデバッグ性**
   * `sqlc`は慣用的で明示的なSQL呼び出しを生成し、マジックジョインや意図しないイーガーロードなしにパフォーマンスボトルネックを特定・最適化しやすくします。
   * GORMの抽象化は、複雑なクエリをデバッグする際に追跡が困難な不透明な動作につながる可能性があります。

3. **パフォーマンス**
   * `sqlc`はリフレクションオーバーヘッドなしで静的コードを生成し、負荷下でより高速なクエリ実行を実現します。
   * GORMのリフレクションベースのクエリ構築は追加のランタイムコストを発生させます。

---

### **OpenAPIコード生成: [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)**

`OpenAPI Generator`も検討しましたが、`oapi-codegen`を選択しました：

1. **Go慣用的なコード生成**
   * `oapi-codegen`はGo専用に設計されており、Go規約に従ったクリーンで慣用的なGoコードを生成します。
   * OpenAPI Generatorは多くの言語をサポートしますが、しばしば冗長で、Goらしくないコードを生成し、追加のカスタマイズが必要です。

2. **焦点を絞ったスコープとシンプルさ**
   * `oapi-codegen`はモデルとクライアント/サーバーインターフェースの生成に焦点を当てており、私たちの「モデルのみ」のユースケースに完璧に合致します。
   * OpenAPI Generatorは複数言語での完全なコード生成を目的とした包括的なツールであり、シンプルなモデル生成には過剰です。

3. **Goエコシステムとの統合**
   * `oapi-codegen`は追加設定なしでEcho、Chi、net/httpなどの人気のあるGoフレームワークとシームレスに統合されます。現在はモデルのみに使用していますが、将来的な拡張性とカスタマイズ性を考慮して選択しました。
   * OpenAPI GeneratorはGoウェブフレームワークとクリーンに統合するためにテンプレートのカスタマイズと追加の適応作業が必要です。

4. **保守と設定のオーバーヘッド**
   * `oapi-codegen`は最小限の設定で済み、シンプルなコマンドラインフラグで何を生成するかを指定できます。
   * OpenAPI Generatorは複雑なテンプレート管理と設定ファイルが必要で、単純なモデル生成には不要な複雑さを追加します。

---

### **依存性注入ツール: [Wire](https://github.com/google/wire) / [Fx](https://github.com/uber-go/fx)**

専用のDIフレームワークを見送り、手動依存性注入を選択しました：

1. **シンプルさと明確性**
   * 手動DIはコード生成やフレームワークの抽象化なしでプレーンなGoコードを使用します
   * 依存関係グラフは明示的でコードベース全体で追跡が容易です
   * ビルド時のツールや特別なコマンドが不要です

2. **標準的なGoのイディオム**
   * ほとんどのGoプロジェクトは、小〜中規模の依存関係グラフに手動DIを使用しています
   * 「巧妙さよりも明確さが優れている」という原則に従います
   * Goに精通した新しい開発者のオンボーディング時間を短縮します

3. **オーバーヘッドや魔法なし**
   * コード生成ステップ（Wire）やランタイムリフレクション（Fx）がありません
   * スタックトレースとIDEのナビゲーションがシームレスに機能します
   * 明示的なコンストラクタ呼び出しによりデバッグが容易です

Goバックエンドプロジェクトを開始する場合、手動DIは通常、シンプルさ、保守性、明確性の最良のバランスを提供します。また、Goベースのプロジェクトで依存性注入ツールを使用することは一般的ではありません。

## ✅ なぜこのスタックなのか？

- **最小限だが本番環境対応**
- **パフォーマンスを意識した選定**
- **理解・拡張が容易**
- **小〜大規模チーム**でうまく機能
- クリーンアーキテクチャによる**明確な関心の分離**を促進

## 🔄 将来の検討事項

プロジェクトのニーズに応じて、以下が追加される可能性があります：
- 認証とセッション管理（プロジェクト固有の要件）
- サービス間通信のためのgRPCサポート
- バックグラウンドジョブ処理の強化
- 監視・可観測性統合（Prometheus、OpenTelemetry）
- 高トラフィックやユーザのセッション管理用のキャッシュ層（Redis）

## 📝 貢献

コントリビューションしてくれたら嬉しいです！代替ライブラリやパターンを提案する場合は、PRやissueでトレードオフを説明してください。
意見やコメントも大歓迎です！どしどしお待ちしてます！

